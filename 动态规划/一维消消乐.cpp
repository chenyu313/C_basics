//一维消消乐
/*有n个珠子排成一排，每一个珠子有一个价值wi(可能是负数),你可以选择若干个相邻的珠子使它们同时消去
每消去一对珠子都会使总分数加上两个珠子相乘的分数，每个珠子只能消一次，并且每个珠子还会占位
输入格式：
		输入一个n(1<=n<=10000)，接下来输入n个整数
输出格式：
		输出最大的分数*/
#include<iostream>
using namespace std;
int w[10005];
int dp[10005][2];		//dp[i][0]表示不和前面组合，dp[i][1]表示和前面组合 
int ans; 
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)	//输入n个珠子的价值 
	{
		cin>>w[i];
	}
	dp[1][0]=0;		//第一个没有组合
	for(int j=2;j<=n;j++)
	{
		dp[j][0]=max(dp[j-1][0],dp[j-1][1]);	//不组合，继承前面的最大值
		dp[j][1]=dp[j-1][0]+w[j]*w[j-1];		//相邻组合	
	} 
	ans=max(dp[n][0],dp[n][1]);
	cout<<ans<<endl;
	return 0;
} 
/*样例
8
-9 -5 -4 -2 4 -5 -4 2
*/ 
 
