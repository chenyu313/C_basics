//迷宫问题
/*
...11111111111111111111111111111
11.111111........1111111111.1111
11.111111..111.11111111.....1111
11.11111111111.1111111111.111111
11.111111.................111111
11.111111.11111111111.11111.1111
11.111111.11111111111.11111..111
11..........111111111.11111.1111
11111.111111111111111.11....1111
11111.111111111111111.11.11.1111
11111.111111111111111.11.11.1111
111...111111111111111.11.11.1111
111.11111111111111111....11.1111
111.11111111111111111111111.1111
111.1111.111111111111111......11
111.1111.......111111111.1111.11
111.1111.11111.111111111.1111.11
111......11111.111111111.1111111
11111111111111.111111111.111...1
11111111111111...............1.1
111111111111111111111111111111..

如上图的迷宫，入口，出口分别：左上角，右下角
"1"是墙壁，"."是通路
求最短需要走多少步？
*/
//bfs
#include<iostream>
#include<queue>
#include<string>
using namespace std;
string map[105];
int n;
bool vis[105][105];
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
bool in(int x,int y)
{
	return 0<=x&&x<n&&0<=y<map[x].length();
}
struct Node
{
	int x,y,step;
	Node(int xx,int yy,int s)
	{
		x=xx;
		y=yy;
		step=s;
	}
};
int bfs(int x,int y)
{
	queue<Node> q;			//构造一个队列 
	q.push(Node(x,y,0));	//把起点压入队列 
	vis[x][y]=true;			//标记访问
	//当队列不为空时取出队首
	while(!q.empty()){
		Node now=q.front();		//取出队首
		q.pop();		//弹出
		for(int i=0;i<4;i++){
			int xx=now.x+dx[i];
			int yy=now.y+dy[i];
			if(in(xx,yy) && !vis[xx][yy] && map[xx][yy]=='.'){
				if(xx==n-1 && yy==map[xx].length()-1){
					return now.step+1;
				}else{
					vis[xx][yy]=true;
					q.push(Node(xx,yy,now.step+1));
				}
			}
		} 
	}
	return -1;
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>map[i];
	}
	cout<<bfs(0,0)<<endl; 
	return 0;	
}
//bfs统一公式，队列取队首，若找到则弹出，否则继续弹队首，存队尾 
