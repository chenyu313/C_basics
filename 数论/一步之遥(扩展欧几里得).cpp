//一步之遥
/*
从昏迷中醒来，小明发现自己被关在X星球的废矿车里。
矿车停在平直的废弃的轨道上。
他的面前是两个按钮，分别写着“F”和“B”。
小明突然记起来，这两个按钮可以控制矿车在轨道上前进和后退。
按F，会前进97米。按B会后退127米。
透过昏暗的灯光，小明看到自己前方1米远正好有个监控探头。
他必须设法使得矿车正好停在摄像头的下方，才有机会争取同伴的援助。
或许，通过多次操作F和B可以办到。
矿车上的动力已经不太足，黄色的警示灯在默默闪烁…
每次进行 F 或 B 操作都会消耗一定的能量。
小明飞快地计算，至少要多少次操作，才能把矿车准确地停在前方1米远的地方。
请填写为了达成目标，最少需要操作的次数。
*/
/*
扩展欧几里得算法
根据题目列出方程：97 * x - 127 * y = 1，这是一个不定方程，要求不定方程的整数解，用扩展欧几里得算法。
为了介绍扩展欧几里得，我们先介绍一下贝祖定理：

           即如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。

换句话说，如果ax+by=m有解，那么m一定是gcd(a,b)的若干倍。（可以来判断一个这样的式子有没有解）

有一个直接的应用就是 如果ax+by=1有解，那么gcd(a,b)=1；

要求出这个最大公因数gcd(a,b)，我们最容易想到的就是古老悠久而又相当强大的辗转相除法：
当到达递归边界的时候，b==0，a=gcd(a,b) 这时可以观察出来这个式子的一个解：a*1+b*0=gcd(a,b)，x=1,y=0，
注意这时的a和b已经不是最开始的那个a和b了，所以我们如果想要求出解x和y，就要回到最开始的模样。
  假设当前我们在求的时a和b的最大公约数，而我们已经求出了下一个状态：b和a%b的最大公因数，并且求出了一组x1和y1使得                         
  										 b*x1+(a%b)*y1=gcd
这时我们可以试着去寻找这两个相邻状态的关系：

首先我们知道：a%b=a-(a/b)*b；带入：

b*x1 + (a-(a/b)*b)*y1

= b*x1 + a*y1 C (a/b)*b*y1

= a*y1 + b*(x1 C a/b*y1) = gcd   发现 x = y1 , y = x1 C a/b*y1

这样我们就得到了每两个相邻状态的x和y的转化，就可以在求gcd的同时对x和y进行求值了
*/
//不定方程 不定方程的整数解 
//扩展欧几里得定理 Ax + By = gcd(A,B)有解 
#include<iostream>
#include<math.h>
using namespace std;
int ex_gcd(int a,int b,int &x,int &y)
{
	if(b==0)		//递归基 
	{
		x=1;
		y=0;
		return a;
	}
	int ans=ex_gcd(b,a%b,x,y);
	int t=x;
	x=y;
	y=t-a/b*x;
	return ans;
}
int main()
{
	int x,y;
	int g=ex_gcd(97,127,x,y);	//97和127的最大公约数
	cout<<g<<endl; 
	cout<<x<<" "<<y<<endl;
	cout<<abs(x)+abs(y)<<endl;	//步数总和 
	return 0;	
} 
//该题主要用扩展欧几里得算法求二元一次等式，其中右边的值一定是左边的最大公约数 

